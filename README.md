# Подключаемые заголовочные файлы

```c
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
```

**lua.h** - содержит основные функции и типы. Название функций начинаются с префикса *lua_*.  Также имеются библиотеки расширений упрощающие некоторые действия при работе с lua (инициализация, загрузка скриптов и т.п.) Названия расширенных функций обычно начинаются с префикса *luaL_*.

**luaxlib.h** - содержит основной набор дополнительных функций и макросов.

**lualib.h** - содержит функции погрузки Lua библиотек. Без них не будут определены (не будут работать) такие функции как print, math.sin и т.п. В зависимости от потребностей можно подгрузить все библиотеки сразу или отдельно по группам.

# Минимальное приложение

Загружает скрипт из файла **script.lua** и выполняет его.

```c
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

int main() {
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	if (luaL_dofile(L, "script.lua")) {
		printf("error: %s\n", lua_tostring(L, -1));
	}
	lua_close(L);
	return 0;
}
```
**

# Вызов Cи функции из Lua

Пользовательская функция написанная на Си должна соответствовать типу lua_CFunction. Функция возвращает число результатов помещенных в стек, обычно это 0 - функция не возвращает ничего, 1 - функция возвращает один параметр. Возвращаемое значение помещается в стек.

```c
typedef int (*lua_CFunction) (lua_State *L);
```
**

Следующая функция получит из стека два числа, напечатает их значения и вернет сумму чисел.

```c
int foo(lua_State *L) {
	double a = lua_tonumber(L, -2);
	double b = lua_tonumber(L, -1);
	printf("a = %f, b = %f\n", a, b);
	lua_pushnumber(L, a + b);
	return 1;
}
```

Перед вызовом нужно зарегистрировать Си функцию, после чего ее вызов будет доступен из скрипта Lua.

```c
lua_pushcfunction(L, foo);
lua_setglobal(L, "foo");
```

Lua скрипт выглядит так.

```lua
local sum = foo(12, 15)
print(sum)
```

# Вызов Lua функции из Си

Внутри скрипта объявляем функцию bar, либо создаем lua_CFunction.

```lua
function bar(a, b)
	print("hello from Lua")
	print("bar a = ", a)
	print("bar b = ", b)
	return a + b
end
```

Далее в С выполняем следующие действия.

1. Помещаем в стек глобальную функцию bar. (lua_getglobal)
2. Помещаем в стек значения 5 и 7. (lua_pushnumber)
3. Делаем вызов (lua_call) указывая число передаваемых значений (2) и число значений которые мы ожидаем получить после вызова (1).
4. Печатаем результат выполнения функции, получая его с вершины стека. (lua_tonumber)
5. Освобождаем стек. Вызов lua_call удалит помещенные в стек параметры функции и оставит только результат. Поэтому удаляем из стека только один элемент. (lua_pop)

```c
lua_getglobal(L, "bar");
lua_pushnumber(L, 5);
lua_pushnumber(L, 7);
lua_call(L, 2, 1);
printf("bar return: %f\n", lua_tonumber(L, -1));
lua_pop(L, 1);
```
