# Подключаемые заголовочные файлы

```c
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
```

**lua.h** - содержит основные функции и типы. Название функций начинаются с префикса *lua_*.  Также имеются библиотеки расширений упрощающие некоторые действия при работе с lua (инициализация, загрузка скриптов и т.п.) Названия расширенных функций обычно начинаются с префикса *luaL_*.

**luaxlib.h** - содержит основной набор дополнительных функций и макросов.

**lualib.h** - содержит функции погрузки Lua библиотек. Без них не будут определены (не будут работать) такие функции как print, math.sin и т.п. В зависимости от потребностей можно подгрузить все библиотеки сразу или отдельно по группам.

# Минимальное приложение

Загружает скрипт из файла **script.lua** и выполняет его.

```c
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

int main() {
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	if (luaL_dofile(L, "script.lua")) {
		printf("error: %s\n", lua_tostring(L, -1));
	}
	lua_close(L);
	return 0;
}
```

# Вызов Cи функции из Lua

Пользовательская функция написанная на Си должна соответствовать типу lua_CFunction. Функция возвращает число результатов помещенных в стек, обычно это 0 - функция не возвращает ничего, 1 - функция возвращает один параметр. Возвращаемое значение помещается в стек.

```c
typedef int (*lua_CFunction) (lua_State *L);
```

Следующая функция получит из стека два числа, напечатает их значения и вернет сумму чисел.

```c
int foo(lua_State *L) {
	double a = lua_tonumber(L, -2);
	double b = lua_tonumber(L, -1);
	printf("a = %f, b = %f\n", a, b);
	lua_pushnumber(L, a + b);
	return 1;
}
```

Перед вызовом нужно зарегистрировать Си функцию, после чего ее вызов будет доступен из скрипта Lua.

```c
lua_pushcfunction(L, foo);
lua_setglobal(L, "foo");
```

Lua скрипт выглядит так.

```lua
local sum = foo(12, 15)
print(sum)
```

# Вызов Lua функции из Си

Внутри скрипта объявляем функцию bar, либо создаем lua_CFunction.

```lua
function bar(a, b)
	print("hello from Lua")
	print("bar a = ", a)
	print("bar b = ", b)
	return a + b
end
```

Далее в С выполняем следующие действия.

1. Помещаем в стек глобальную функцию bar. (lua_getglobal)
2. Помещаем в стек значения 5 и 7. (lua_pushnumber)
3. Делаем вызов (lua_call) указывая число передаваемых значений (2) и число значений которые мы ожидаем получить после вызова (1).
4. Печатаем результат выполнения функции, получая его с вершины стека. (lua_tonumber)
5. Освобождаем стек. Вызов lua_call удалит помещенные в стек параметры функции и оставит только результат. Поэтому удаляем из стека только один элемент. (lua_pop)

```c
lua_getglobal(L, "bar");
lua_pushnumber(L, 5);
lua_pushnumber(L, 7);
lua_call(L, 2, 1);
printf("bar return: %f\n", lua_tonumber(L, -1));
lua_pop(L, 1);
```

# Обертка для Си структуры или С++ класса

Для примера возьмем Си структуру описывающую параметры игрока.

```c
typedef struct Player {
	int hp;
	int mp;
} Player;
```

Зададим функцию конструктор которая будет инициализировать данные при создании объекта. Функция конструктора будет закреплена как штатное событие объекта "new" вызываемую при создании объетка.

1. Создаем Lua значение хранящее пользовательские данные. При вызове lua_newuserdata указываем размер выделяемого блока памяти и получаем указатель на выделенный блок памяти. Выделенный блок памяти будет удален сборщиком мусора в момент когда переменная станет ненужной.
2. Инициализируем значения полей структуры.
3. Устанавливаем для переменной userdata метатаблицу Player благодаря чему наследуем методы и функции от прототипа Player.
4. Возвращаем 1 параметр - созданная нами переменная.

```c
int constructor(lua_State* L) {
	Player* data = lua_newuserdata(L, sizeof(Player));
	data->hp = lua_tonumber(L, 1);
	data->mp = lua_tonumber(L, 2);
	luaL_getmetatable(L, "Player");
	lua_setmetatable(L, -2);
	return 1;
}
```

Функция destructror будет вызываться как штатное событие "__gc" в момент освобождения памяти сборщиком мусора и используется для деинициализации данных пользователя - выделенной памяти, созданных объектов и прочее.

```c
int destructror(lua_State* L) {
	return 0;
}
```

Функция foo - метод класса Player выводящий информацию об объекте.

```c
int foo(lua_State* L) {
	Player* data = lua_touserdata(L, 1);
	printf("hp: %u\nmp: %u\n", data->hp, data->mp);
	return 0;
}
```

Определяем прототип класса Player

Создаем списко функций для прототипа класса Player в виде массива значений типа luaL_Reg - пар значений <имя, функция>. Список должен оканчиваться двумя значениями типа NULL.

```c
const luaL_Reg reg[] = {
	{"new", constructor},
	{"foo", foo},
	{"__gc", destructror},
	{NULL, NULL}
};
```

1. Создаем новую метатаблицу
2. Устанавливаем список функций
3. Замыкаем значение __index для созданной нами метатаблицы Player на саму себя. Нужно это для того, чтобы можно было вызывать установленные нами ранее функции. Для того, чтобы не потерять значение метатаблицы на вершине стека при вызове lua_setfield копируем значение вершины стека командой lua_pushvalue. 
4. Связываем Player метатаблицу с глобальным именем Player

```c
luaL_newmetatable(L, "Player");
luaL_setfuncs(L, reg, 0);
lua_pushvalue(L, -1);
lua_setfield(L, -1, "__index");
lua_setglobal(L, "Player");
```

Теперь можно создавать экземпляры объектов Player в Lua

```lua
p = Player.new(10, 30)
p:foo()

```

По анологии можно обернуть C++ класс.

В конструкторе создаем блок данных в виде указателя на экземпляр класса и создаем новый класс по средствам вызова new

```c++
MyClass** data = lua_newuserdata(L, sizeof(MyClass*));
*data = new MyClass();
```

В деструкторе не забываем удалить класс.

```c++
MyClass** data = lua_touserdata(L, 1);
delete *data;
```

# Вызов метода класса из Си

1. Помещаем в стек переменную с методом (переменная p из прошлого примера "Обертка для Си структуры или С++ класса").
2. Получаем поле с именем "foo".
3. Проверяем является ли foo функцией, если нет, освобождаем стек.
4. Помещаем значение переменной "p" на вершину стека, для указания self параметра.
5. Убираем значение переменной "p" полученной в начале с третьей позиции стека, оно больше ненужно.
6. Вызываем функцию. Аналогично p::foo() либо p.foo(p).

```c
lua_getglobal(L, "p");
lua_getfield(L, -1, "foo");
if (lua_isfunction(L, -1)) {
	lua_pushvalue(L, -2);
	lua_remove(L, -3);
	lua_call(L, 1, 0);
} else {
	lua_pop(L, 2);
}
```

# Указатель на Lua объект (Reference)

Может быть полезен для определения Lua объекта владельца или переданного объекта.

Минус - блокирует индексируемое Lua значение от сборки мусора. Требует ручной разблокировки.

Получить индекс переменной сохраненной в вершине стека. Вызов заблокирует переменную от сборки мусора.

```c
luaL_ref(L, LUA_REGISTRYINDEX); 
```

Освободить значение. После вызова станет доступна сборщику мусора. Индекс станет бесполезным.

В случае если userdata хранит ссылку на саму себя, бесполезно помещать вызов освобождения в событие "__gc", так как оно никогда не будет вызвано.

```c
luaL_unref(L, LUA_REGISTRYINDEX, data->self);
```

Поместить на вершину стека переменную на которую указывает reference.

```c
lua_rawgeti(L, LUA_REGISTRYINDEX, data->self);
```

# Геттеры и сеттеры (getters & setters)

Для получения и установки значения Lua использует поля __index и __newindex. Значение может быть метатаблицей (см. "Обертка для Си структуры или С++ класса") или функцией вида f(self, key) или f(self, key, value) возвращающая значение над которым должно быть произведено действие, либо выполняющая действие.

Получение значения:
В стеке (self, key)

```c
int object___index(lua_State* L) {
	const char* key = lua_tostring(L, 2);
	
	// Код пользователя
	// В случае если key == "value" возвращаем 42
	// print(p.value) напечатает 42

	if (!strcmp(key, "value")) {
		lua_pushinteger(L, 42);
		return 1;		
	}

	// Передаем запрос метатаблице (прототипу)
	// Дальше Lua все сделает сама

	luaL_getmetatable(L, "Object");
	lua_getfield(L, -1, key);
	lua_remove(L, -2);
	return 1;
}
```

Установка значения: 
В стеке (self, key, value)

```c
int object___newindex(lua_State* L) {
	const char* key = lua_tostring(L, 2);
	Object* data = lua_touserdata(L, 1);

	// Если key == "value" выполняем код пользователя устанавливающий значение value

	if (!strcmp(key, "value")) {
		int v = lua_tointeger(L, 3);
		data->v = v;
		printf("set value to %u\n", v);
		return 0;
	}

	// В случае указания неведомого ключа генерируем ошибку
	// Необязательно, если не генерировать, то просто ничего не произойдет

	lua_pushliteral(L, "incorrect argument");
	lua_error(L);

	return 0;
}
```